<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Articles on Noah Hailegiorgis</title>
        <link>https://noahhaile.com/articles/</link>
        <description>Recent content in Articles on Noah Hailegiorgis</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 30 May 2025 10:57:26 +0300</lastBuildDate>
        <atom:link href="https://noahhaile.com/articles/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>My New Favorite Architecture: Using n8n as a Mid Server</title>
            <link>https://noahhaile.com/articles/my-favorite-architecture/</link>
            <pubDate>Fri, 30 May 2025 10:57:26 +0300</pubDate>
            
            <guid>https://noahhaile.com/articles/my-favorite-architecture/</guid>
            <description>&lt;p&gt;For a while, my pride told me visual builders weren’t for &lt;em&gt;professional&lt;/em&gt; engineers. I never said it out loud, but I thought it: drag-and-drop tools were suitable for prototypes, business folks, or anyone trying to avoid writing &lt;em&gt;conventional&lt;/em&gt; code. They weren’t for people who knew how to build things &lt;strong&gt;the established way.&lt;/strong&gt; Then I started using n8n to build AI agents, and it didn’t take long before my conviction began to waver. Because pretty quickly, I realized that instead of a limitation, this was a superpower.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>For a while, my pride told me visual builders weren’t for <em>professional</em> engineers. I never said it out loud, but I thought it: drag-and-drop tools were suitable for prototypes, business folks, or anyone trying to avoid writing <em>conventional</em> code. They weren’t for people who knew how to build things <strong>the established way.</strong> Then I started using n8n to build AI agents, and it didn’t take long before my conviction began to waver. Because pretty quickly, I realized that instead of a limitation, this was a superpower.</p>
<h2 id="the-architecture">The Architecture</h2>
<p>Now, n8n is a core part of how I build. Not as a replacement for my backend, but as a mid server, a logic layer that handles:</p>
<ul>
<li>Third-party integrations</li>
<li>Cron jobs</li>
<li>Automation flows</li>
<li>AI agents</li>
<li>Webhook juggling</li>
</ul>
<p>All things that don’t need to live in my backend, but still need to be coordinated, extended, and monitored. n8n and my backend communicate seamlessly over webhooks. n8n handles the flow, the timing, the retries, the service coordination. My backend owns state, authentication, data persistence, which represent the critical boundaries. The result is a clear split: logic orchestration in one place, core systems in another. It&rsquo;s neither a monolith, microservices, nor serverless. It’s a hybrid approach that works.</p>
<h2 id="code-reuse-without-the-overhead">Code Reuse Without the Overhead</h2>
<p>One thing I noticed fast: stuff just doesn’t get duplicated as much. Workflows become natural units of reuse. One webhook handler can become three different triggers. An agent prompt with branching logic can be cloned and remixed. A cron-based report doesn’t have to live in a buried script anymore; it’s visible, tweakable, and versioned. And I don’t have to make the tradeoff between speed and clarity. A change that would normally mean touching four files, two services, and a deployment&hellip; just becomes a new node and a test run.</p>
<h2 id="the-ai-layer-that-actually-scales">The AI Layer That Actually Scales</h2>
<p>Once I started layering in AI-native behavior, this setup really hit its stride. AI integrations are inherently async, API-intensive, and often experimental. You’re juggling prompts, chaining models, enriching outputs, and coordinating side effects. Trying to bake all that into a traditional backend is chaos.</p>
<p>With n8n, I construct agent pipelines with a visual and intuitive workflow. One part fetches history, one part formats the context, one calls a model, another logs the result, another decides what to do next. If a branch fails? I can retry it, isolate it, rewire it. It makes experimentation genuinely feasible. I can treat AI agents as dynamic entities, not static endpoints.</p>
]]></content>
        </item>
        
        <item>
            <title>Great Software Engineers Build for a Lifetime</title>
            <link>https://noahhaile.com/articles/build-for-a-lifetime/</link>
            <pubDate>Mon, 12 May 2025 10:57:26 +0300</pubDate>
            
            <guid>https://noahhaile.com/articles/build-for-a-lifetime/</guid>
            <description>&lt;p&gt;Lately, something quiet but significant has been shifting in how I think about writing software. It’s a growing realization that feels less like a sudden insight and more like a path I&amp;rsquo;m still walking: that maybe, just maybe, the goal isn&amp;rsquo;t just to solve the problem in front of you, but to build something that could last.&lt;/p&gt;
&lt;p&gt;When I first started coding, everything felt temporary. Projects were quick sprints – homework due tomorrow, a script to get rid of an annoying manual task, a side idea I knew I&amp;rsquo;d probably drop next week. My focus was simple: make it run. Structure, naming things well, comments – that all felt like nice-to-haves I didn&amp;rsquo;t have time for. Get it working, move on. And for a while, that approach worked well enough.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>Lately, something quiet but significant has been shifting in how I think about writing software. It’s a growing realization that feels less like a sudden insight and more like a path I&rsquo;m still walking: that maybe, just maybe, the goal isn&rsquo;t just to solve the problem in front of you, but to build something that could last.</p>
<p>When I first started coding, everything felt temporary. Projects were quick sprints – homework due tomorrow, a script to get rid of an annoying manual task, a side idea I knew I&rsquo;d probably drop next week. My focus was simple: make it run. Structure, naming things well, comments – that all felt like nice-to-haves I didn&rsquo;t have time for. Get it working, move on. And for a while, that approach worked well enough.</p>
<p>But gradually, almost without noticing, the friction started building. Going back to old code became a chore. Why was I writing this same setup again? Why did authentication always feel like hacking something together from scratch every time? Why were interfaces left looking like rough placeholders I’d promised myself I’d fix later but never did? It wasn&rsquo;t just frustration with the code itself; it was a growing sense of regret about the choices I didn&rsquo;t make – the reusable bits I didn’t build, the foundations I skipped that now slowed me down.</p>
<p>I started to get tired of feeling like I was starting from zero when it felt like I should have a base to build from. This constant rebuilding wasn&rsquo;t just inefficient; it felt like I was limiting my own ability to work on bigger, more interesting problems. You can only build so tall if you&rsquo;re always rebuilding the ground floor.</p>
<p>That’s when the idea began to form: maybe good code isn&rsquo;t just about the speed of getting something done right now. Maybe it’s more about getting it done in a way that respects your future self, anyone else who might touch this code, or even just the possibility that this work might be useful again. It&rsquo;s about starting to build with the quiet assumption that this might live on.</p>
<p>This shift, subtle as it is, changes how you look at things.</p>
<p>Projects start to feel less like one-off experiments and more like potential building blocks. You begin to see functions, modules, even READMEs as assets that could be valuable again. Naming things clearly, writing code that explains its intent, thinking about structure that can accommodate growth – these things start to feel less like rules and more like practical steps to make future life easier. Version control isn&rsquo;t just a team requirement; it becomes a personal tool for reliability and traceability.</p>
<p>Things like backups, clear commit messages, maybe even a quick note on a design idea – they start to feel less like &ldquo;overhead&rdquo; and more like basic responsibility, a way of caring for the work and advancing as an engineer. And this care, this commitment to building well, subtly but powerfully reinforces how much value your work truly has – both to you and to anyone who might encounter it.</p>
<p>And you start to notice that the more you care about building sustainably, the more the work itself seems to gain value, sometimes in unexpected ways. Code you wrote months ago gets referenced. A tool you built for one thing finds a use elsewhere. That small utility function you cleaned up two years ago shows up in another project, and it just&hellip; works.</p>
<p>It&rsquo;s in these moments that building like a professional starts to click into place.</p>
<p>You&rsquo;re not just writing disposable scripts; you&rsquo;re trying to build systems that can be expanded. You start thinking a little more about architecture, even in small ways, rather than just the quickest hack. And even when you think you&rsquo;re writing something throwaway, there&rsquo;s this lingering sense that it&rsquo;s worth making it reasonably clear, just in case.</p>
<p>Because, as I&rsquo;m learning, &ldquo;throwaway&rdquo; code has a funny habit of sticking around.</p>
<p>And maybe the most profound part of this evolving perspective is starting to look further out. Not just to the next deadline or feature, but with the idea that this code could become a foundation – for something you haven&rsquo;t thought of yet, for a team you might join, or just for making your own future work smoother. This ability to build upon existing, stable systems you&rsquo;ve created (or contributed to) isn&rsquo;t just a best practice; it feels increasingly like the only way to genuinely progress as an engineer and tackle problems of greater complexity and impact. You simply can&rsquo;t get very far if you&rsquo;re stuck reinventing the wheel every single time.</p>
<p>Every function you make reusable, every pattern you adopt, every comment that clarifies intent – it feels like building your own personal toolkit, your own infrastructure. It&rsquo;s less about just putting out fires and more about shaping a body of work that reflects a growing care for the craft.</p>
<p>That, I think, is where the real growth happens. It&rsquo;s less about building fast, and more about learning to build foundations for the future.</p>
]]></content>
        </item>
        
        <item>
            <title>Blazing Fast &amp; Dirt Cheap: Nginx, Cloudflare, and a VPS</title>
            <link>https://noahhaile.com/articles/dirt-cheap-web-apps/</link>
            <pubDate>Sat, 22 Mar 2025 10:57:26 +0300</pubDate>
            
            <guid>https://noahhaile.com/articles/dirt-cheap-web-apps/</guid>
            <description>&lt;p&gt;Building modern web applications with frameworks like React, Vue, or Angular is powerful, but hosting them can sometimes feel complex or costly. What if you could get global CDN speeds for your frontend and efficiently host your backend API, all for just a few bucks a month?&lt;/p&gt;
&lt;p&gt;You absolutely can. By combining a lean VPS, the versatile Nginx web server, and Cloudflare&amp;rsquo;s incredible free tier, you can create a setup that embraces the best parts of the Jamstack architecture: serving your static frontend globally at light speed while efficiently handling dynamic API requests from a low-cost server.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>Building modern web applications with frameworks like React, Vue, or Angular is powerful, but hosting them can sometimes feel complex or costly. What if you could get global CDN speeds for your frontend and efficiently host your backend API, all for just a few bucks a month?</p>
<p>You absolutely can. By combining a lean VPS, the versatile Nginx web server, and Cloudflare&rsquo;s incredible free tier, you can create a setup that embraces the best parts of the Jamstack architecture: serving your static frontend globally at light speed while efficiently handling dynamic API requests from a low-cost server.</p>
<p><strong>Why This Stack is Perfect for Modern Web Apps:</strong></p>
<ol>
<li><strong>Cheap VPS ($3-5/month):</strong> Your affordable, controllable home base. Use it to serve the initial files and, more importantly, to run your backend API (Node.js, Python, Go, etc.) if you have one. Providers like Hetzner, Vultr, DigitalOcean offer plans that fit the bill.</li>
<li><strong>Nginx (Free, Fast, Flexible):</strong> It&rsquo;s not just a static file server! Nginx excels at serving your <em>built</em> frontend assets (the static HTML, CSS, JS generated by your framework&rsquo;s build process). Crucially, it&rsquo;s also a fantastic <em>reverse proxy</em>, meaning it can intelligently route requests for <code>/api</code> (or similar paths) to your backend application running on the same VPS.</li>
<li><strong>Cloudflare (The Free Performance Engine):</strong> This is the key to speed and savings.
<ul>
<li><strong>Global CDN:</strong> Serves your static frontend from datacenters worldwide. Users load your app&rsquo;s interface almost instantly from a server near them.</li>
<li><strong>Caching:</strong> We&rsquo;ll tell Cloudflare to aggressively cache your <em>static frontend</em>. This means <strong>most users won&rsquo;t even hit your VPS</strong> for the interface files, dramatically reducing its load. Your server only needs to worry about dynamic API calls.</li>
<li><strong>Security:</strong> Provides essential protection against common web threats.</li>
</ul>
</li>
</ol>
<p><strong>Let&rsquo;s Set Up Your Modern Hosting Platform:</strong></p>
<p><strong>Step 1: Your Server&rsquo;s Foundation (VPS + Nginx)</strong></p>
<ol>
<li><strong>Get a VPS:</strong> Sign up with a provider and get a basic Linux VPS (Ubuntu is common). Note its IP address.</li>
<li><strong>Connect via SSH:</strong> Use SSH to access your server&rsquo;s command line.</li>
<li><strong>Install Nginx:</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install nginx -y
</span></span></code></pre></div></li>
<li><strong>Create a Directory for Your Frontend Build:</strong> Instead of a generic <code>html</code> folder, let&rsquo;s use something more descriptive. This is where you&rsquo;ll put the <em>output</em> of your <code>npm run build</code> or similar command (e.g., the <code>build</code> or <code>dist</code> folder).
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Replace &#39;yourdomain.com&#39; with your actual domain</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># You might choose /srv/ or /var/www/ based on preference</span>
</span></span><span style="display:flex;"><span>sudo mkdir -p /var/www/yourdomain.com/frontend
</span></span></code></pre></div></li>
<li><strong>Upload Your Built Frontend:</strong> Copy the contents of your framework&rsquo;s build output directory (e.g., everything inside <code>my-react-app/build/</code>) into the <code>/var/www/yourdomain.com/frontend/</code> directory on your VPS using <code>scp</code>, SFTP (FileZilla), <code>rsync</code>, or Git deployment.</li>
<li><strong>Configure Nginx for Your Frontend:</strong> Create an Nginx configuration file:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/nginx/sites-available/yourdomain.com
</span></span></code></pre></div>Paste in this configuration, adjusting <code>yourdomain.com</code> and the <code>root</code> path if you chose differently:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#66d9ef">server</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">listen</span> <span style="color:#ae81ff">80</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">server_name</span> <span style="color:#e6db74">yourdomain.com</span> <span style="color:#e6db74">www.yourdomain.com</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Path to your built frontend files
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">root</span> <span style="color:#e6db74">/var/www/yourdomain.com/frontend</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">index</span> <span style="color:#e6db74">index.html</span> <span style="color:#e6db74">index.htm</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">location</span> <span style="color:#e6db74">/</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Crucial for Single Page Applications (SPAs) like React/Vue/Angular:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e"># Try serving the exact file requested ($uri), then try it as a directory ($uri/),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e"># If neither exists, fall back to serving /index.html.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e"># This lets your frontend framework handle routing.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">try_files</span> $uri $uri/ <span style="color:#e6db74">/index.html</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Basic security headers (optional but good practice)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">add_header</span> <span style="color:#e6db74">X-Frame-Options</span> <span style="color:#e6db74">&#34;SAMEORIGIN&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">add_header</span> <span style="color:#e6db74">X-Content-Type-Options</span> <span style="color:#e6db74">&#34;nosniff&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">add_header</span> <span style="color:#e6db74">Referrer-Policy</span> <span style="color:#e6db74">&#34;strict-origin-when-cross-origin&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">add_header</span> <span style="color:#e6db74">Permissions-Policy</span> <span style="color:#e6db74">&#34;interest-cohort=()&#34;</span>; <span style="color:#75715e"># Disable FLoC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div>Save the file (<code>Ctrl+X</code>, <code>Y</code>, <code>Enter</code>).</li>
<li><strong>Enable Site &amp; Restart Nginx:</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ln -s /etc/nginx/sites-available/yourdomain.com /etc/nginx/sites-enabled/
</span></span><span style="display:flex;"><span>sudo rm /etc/nginx/sites-enabled/default <span style="color:#75715e"># Remove default config if present</span>
</span></span><span style="display:flex;"><span>sudo nginx -t <span style="color:#75715e"># Test config</span>
</span></span><span style="display:flex;"><span>sudo systemctl restart nginx <span style="color:#75715e"># Apply changes</span>
</span></span></code></pre></div>Your frontend app should now be accessible via your VPS IP address.</li>
</ol>
<p><strong>Step 2: Supercharge with Cloudflare</strong></p>
<ol>
<li><strong>Sign up &amp; Add Domain:</strong> Create a free Cloudflare account and add your domain.</li>
<li><strong>Point DNS to VPS:</strong> In Cloudflare&rsquo;s DNS settings, delete any conflicting &lsquo;A&rsquo;, &lsquo;AAAA&rsquo;, or &lsquo;CNAME&rsquo; records for your root domain (<code>@</code>) and <code>www</code>. Add an &lsquo;A&rsquo; record for <code>@</code> pointing to your VPS IP Address, and a &lsquo;CNAME&rsquo; record for <code>www</code> pointing to <code>@</code> (or yourdomain.com). <strong>Ensure both have the Proxy status set to Orange (Proxied).</strong></li>
<li><strong>Update Nameservers:</strong> Go to your domain registrar and change the nameservers to the ones Cloudflare provides. (Allow time for this change to propagate).</li>
<li><strong>Configure SSL/TLS:</strong> In Cloudflare, set SSL/TLS mode to <strong>Full (Strict)</strong> for best security. (Consider installing a free Let&rsquo;s Encrypt certificate on Nginx using <code>certbot</code> for full end-to-end encryption).</li>
</ol>
<p><strong>Step 3: Cache the Frontend Aggressively (Load Reduction!)</strong></p>
<p>This is where you drastically reduce load on your VPS.</p>
<ol>
<li>Go to <strong>Rules -&gt; Page Rules</strong> in Cloudflare.</li>
<li>Click <strong>Create Page Rule</strong>.</li>
<li><strong>URL:</strong> <code>*yourdomain.com/*</code> (Applies to everything).</li>
<li><strong>Settings:</strong>
<ul>
<li><strong>Cache Level:</strong> <strong>Cache Everything</strong> (Caches the HTML, CSS, JS of your frontend).</li>
<li><strong>Edge Cache TTL:</strong> Choose how long Cloudflare caches before checking your server (e.g., <code>1 day</code>, or longer if your frontend rarely changes).</li>
</ul>
</li>
<li>Click <strong>Save and Deploy</strong>.</li>
</ol>
<p><strong>The Result:</strong> Visitors worldwide load your app&rsquo;s interface from Cloudflare&rsquo;s edge. Your VPS only gets hit when the cache expires or when API calls are made (see next step).</p>
<p><strong>Critical Note on Deploying Frontend Updates:</strong> When you deploy a new version of your frontend code to the VPS, you <em>must</em> tell Cloudflare to clear its cache so users get the latest version. Go to <strong>Caching -&gt; Configuration -&gt; Purge Cache -&gt; Purge Everything</strong> in Cloudflare.</p>
<p><strong>Step 4 (Optional): Routing API Requests with Nginx</strong></p>
<p>If your application has a backend API (e.g., Node.js/Express running on port 3001, Python/Flask on port 5000) on the <em>same</em> VPS, you can use Nginx to route requests to it.</p>
<ol>
<li><strong>Edit Your Nginx Config:</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/nginx/sites-available/yourdomain.com
</span></span></code></pre></div></li>
<li><strong>Add an API Location Block:</strong> Inside the <code>server { ... }</code> block, <em>before</em> the closing <code>}</code>, add a new <code>location</code> block. This example assumes your API runs on <code>http://localhost:3001</code> and you want requests to <code>yourdomain.com/api/...</code> to go to it:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#75715e"># ... other directives like root, index, existing location / ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Route API requests
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">location</span> <span style="color:#e6db74">/api/</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Forward requests to the backend application running locally on port 3001
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">proxy_pass</span> <span style="color:#e6db74">http://localhost:3001/</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Standard proxy headers to pass along useful info to the backend
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">Host</span> $host;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">X-Real-IP</span> $remote_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">X-Forwarded-For</span> $proxy_add_x_forwarded_for;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">X-Forwarded-Proto</span> $scheme;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Optional: Increase timeouts if your API calls might take longer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e"># proxy_connect_timeout 60s;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e"># proxy_send_timeout 60s;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e"># proxy_read_timeout 60s;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Make sure your main location block for the frontend is still present
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">location</span> <span style="color:#e6db74">/</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">try_files</span> $uri $uri/ <span style="color:#e6db74">/index.html</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Important:</strong> The trailing slash in <code>proxy_pass http://localhost:3001/;</code> can be significant depending on your backend routing setup. Adjust as needed.</li>
</ul>
</li>
<li><strong>Test and Restart Nginx:</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nginx -t
</span></span><span style="display:flex;"><span>sudo systemctl restart nginx
</span></span></code></pre></div></li>
</ol>
<p><strong>API Caching Consideration:</strong> Your &ldquo;Cache Everything&rdquo; rule <em>might</em> cache API responses if your API doesn&rsquo;t send correct <code>Cache-Control</code> headers (like <code>Cache-Control: no-cache, no-store, must-revalidate</code> or <code>Cache-Control: private</code>). Ensure your API sends appropriate headers for dynamic content to prevent Cloudflare from caching it incorrectly. Alternatively, create a <em>second</em> Page Rule specifically for <code>*yourdomain.com/api/*</code> with the setting <code>Cache Level: Bypass</code>.</p>
<p><strong>The Jamstack Payoff: Cost &amp; Performance</strong></p>
<ul>
<li><strong>Cost:</strong> Still around <strong>$4 - $6 per month</strong> (VPS + Domain).</li>
<li><strong>Performance:</strong> Your static frontend (React, Vue, etc.) loads incredibly fast from the global Cloudflare CDN. Your cheap VPS is freed up to solely handle the (often less frequent) dynamic API requests. This is a highly efficient and scalable architecture.</li>
</ul>
<p><strong>Conclusion: Modern Hosting, Simplified</strong></p>
<p>By combining a low-cost VPS, the efficiency of Nginx (for both static files and API routing), and the powerful caching of Cloudflare, you achieve a high-performance hosting setup for modern web applications without the high cost. It&rsquo;s a practical, affordable way to leverage Jamstack principles: serve static fast, handle dynamic smart. Go build something awesome!</p>
]]></content>
        </item>
        
        <item>
            <title>Hello World</title>
            <link>https://noahhaile.com/articles/hello-world/</link>
            <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
            
            <guid>https://noahhaile.com/articles/hello-world/</guid>
            <description>&lt;p&gt;Test Article&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>Test Article</p>
]]></content>
        </item>
        
    </channel>
</rss>
